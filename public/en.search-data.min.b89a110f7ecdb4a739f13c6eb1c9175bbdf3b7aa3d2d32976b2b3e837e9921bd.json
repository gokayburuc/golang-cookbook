[{"id":0,"href":"/docs/posts/hello-world/","title":"Hello World Uygulaması ","section":"Docs","content":"HELLO WORLD (MERHABA DÜNYA) UYGULAMASI GO programlama diline ve de birçok programlama diline başlayanların ilk olarak yaptıkları şey, ekranda \u0026ldquo;hello world!\u0026rdquo; yazısının yazdırılmasıdır.\nBu örnekte GO programlama dilinin çalışma mantığını öğreneceksiniz.\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World\u0026#34;) } Şimdi örneğimizi parçalarına ayırarak incelemeye başlayalım.\npackage main package main Bu ifade paket deklerasyonu (package declaration) ifadesidir.\nGO programlama dilinde paket modül mimarisi mevcuttur.  "},{"id":1,"href":"/docs/posts/data-types/","title":"Veri Tipleri (Data Types) ","section":"Docs","content":"GO Dilinde Veri Tipleri (Data Types in GO) GO programlama dilinde veri tipleri varsayılan olarak mevcuttur. Ayrıca kullanıcılar tarafından da tanımlanabilirler.\n Varsayılan veri tipleri program kurulduğu an itibariyle tanımlı olan veri tipleridir.    Kullanıcı tanımlı veri tipleri ise kullanıcı tarafından sisteme tanıtılan ve kullanılan veri tipleridir.   Veri Tiplerinin Gruplanması Genel olarak veri tipleri dört ana başlık altında toplanabilir\n Basic type (Temel Veri Tipi ) : Sayılar, metin ve bool ifadeler bu kategoriye girer. int, float, string, bool, complex Aggregate type (Toplanmış Veri Tipi): Dizi ve yapılar bu kategoriye girer. array, struct Reference type (Referans Veri Tipi): İşaretçiler, dilimler, haritalar, işlevler ve kanallar bu kategoriye girer. pointer, slice, map, function, channel Interface Type (Arayüz Veri Tipi) : Arayüzler bu veri tipinde yer alır. interface   1. Temel Veri Tipleri (Basic Types)  String (string) Int (int8, int16, int32, int64) Float ( float32, float64) Boolean (bool) Complex(complex)  Int (Integer-Tamsayı) Tam sayı değerlerlerinin program hafızasında tutulduğu veri tipidir.\nint tanımlaması aşağıdaki şekilde yapılır.\nvar degiskenAdi int = 32 İkinci bir tanımlama yöntemi ise aşağıdaki şekildedir.\ndegiskenAdi := 35 Peki bu sayı tipleri GO programlama tipinde nasıl tanımlanır? Bir örnek ile konuyu açıklamaya çalışalım.\npackage main import (\u0026#34;fmt\u0026#34;) func main(){ var matematikNotu int8 = 85 var edebiyatNotu int8 = 92 fizikNotu = 65 fmt.Println(matematikNotu, edebiyatNotu, fizikNotu) // ortalama \tfmt.Println((matematikNotu + edebiyatNotu + fizikNotu)/3) } Yukarıda tanımlandığı gibi sisteme int ifadesi ile bir değişken tanımladığımızda bu değişken sistem hafızasında integer olarak tutulur ve bu şekilde işlemlere dahil edilir.\nYukarıdaki örnek incelendiğinde matematikNotu isimli bir int ifadesi tanımladık. Bu değerler 1 ile 100 arasında olacağından dolayı veri tipi olarak int8 seçtik. Bu seçim sayılarımızın -127 ve 128 arasında olacağından dolayıdır. Aynı şekilde edebiyatNotu isimli bir int8 ifade tanımladık.\nInt Veri Tipinin Hafızada Kapladığı Yer Tanımladığımız verileriin hafızada kapladığı yer, programcıların en çok kafasını kurcalayan sorulardan biridir. Yazdığınız programın performansını etkiler ve bu sebeple bu temelin ne olduğu ile ilgili bir ön bilgi edinilmesi önemlidir.\nHafızada kapladığı yere ve oluşturulma usullerine göre int veri tipleri aşağıda yer almaktadır.\n   Veri Tipi Açıklama Veri Aralığı     int8 8-bit signed integer -127 ve 128 değerleri arasında yer alır ( signed integer)   int16 16-bit signed integer -32,768 ve +32,767 değerleri arasında yer alır   int32 32-bit signed integer -2147483648 to 2147483647 değerleri arasında yer alır   int64 64-bit signed integer -9,223,372,036,854,775,808 ve 9,223,372,036,854,775,807 değerleri arasında yer alır.   uint8 8-bit unsigned integer 0 ve 255 değerleri arasında yer alır   uint16 16-bit unsigned integer 0 ve 65535\tdeğerleri arasında yer alır   uint32 32-bit unsigned integer 0 ve 4294967295 değerleri arasında yer alır   uint64 64-bit unsigned integer 0 ve (2^64) değerleri arasında yer alır   int Hem int hem de uint, 32 veya 64 bit olmak üzere aynı boyutu içerir.    uint Hem int hem de uint, 32 veya 64 bit olmak üzere aynı boyutu içerir.    rune İnt32 ile eşanlamlıdır ve ayrıca Unicode kod noktalarını temsil eder.    byte uint8 ile eşanlamlıdır.    uintptr İşaretsiz bir tamsayı (unsigned integer) türüdür. Genişliği tanımlanmamıştır, ancak bir işaretçi değerinin tüm bitlerini tutabilir.          32 bit , 64 bit veri tiplerinin mevcut olmasının temel sebebi tutulacak verinin sistemde kaplayacağı yeri düzenlemek içindir.  Birden çok veri tipinin olması sistem hafızasında kaplanacak yer sorunu ile ilgilidir. Milyonlarca sayıdan oluşan bir veri setinin olduğunu düşünelim. Bu sayıların ise 1 ile 1000 arasında yer aldığını düşünelim. Eğer sisteme int16 ( 16 bit tamsayı ) veri tipinde veri girileceğini belirtmez isek sistem bu veri tipleri için int64 (64 bit tamsayı ) imiş gibi muamele edip her bir sayı için 2^64 \u0026lsquo;lük bir yer ayıracaktır. Böylece yapılan işlemler için ayrılan hafıza muazzam boyutlarda artacaktır.\nFloat (Ondalık) Virgül ya da nokta ile ayrılmış ondalıklı değerleri ifade eder. int ifadelerinde olduğu gibi float ifadelerde de hafızada kapladığı yere bakılarak bir seçim yapılır.\nvar sicaklik float32 = 33.25 Diğer bir tanımlama ise şu şekilde yapılabilir.\nsicaklik := 33.25 Veri tipi tanımlaması aşağıdaki tabloya göre belirlenir.\n   Veri Tipi Açıklama Değer Aralığı     float32 32-bit IEEE 754 floating-point number İşaretli bir 32 bit tamsayı değişkeni maksimum 231 − 1 = 2,147,483,647 değerine sahipken, bir IEEE 754 32 bitlik taban-2 kayan noktalı değişkenin maksimum değeri (2 − 2−23) × 2127 ≈ 3.4028235 × 1038 .   float64 64-bit IEEE 754 floating-point number     Float ifadelere ait bir örnek aşağıda yer almaktadır.\npackage main import \u0026#34;fmt\u0026#34; func main() { //float verilerin tanımlanması \ta := 20.45 b := 34.89 //Cikartma islemi \tc := b-a // Sonuc Görüntülemesi \tfmt.Printf(\u0026#34;Result is: %f\u0026#34;, c) // Vier türünün görüntülenmesi \tfmt.Printf(\u0026#34;\\nThe type of c is : %T\u0026#34;, c) } Örneğimizde a ve b olmak üzere iki adet float değişken tanımlanmıştır. İki değere de float64 atanmıştır.\nHATIRLATMA: Eğer float ifade tanımlanırken bir veri tipi seçilmeden tanımlama yapılırsa GO otomatik olarak float64 seçimi yapar.   String (Metin) String veri türü metin verilerinin bir dize olarak tutulduğu veri tipidir. Bu veriler baytlardan oluşur.\nstring ifadeler aşağıdaki şekilde tanımlanır.\nvar degiskenAdi string = \u0026#34;metin ifadesi\u0026#34; ikinci bir tanımlama yöntemi ise aşağıdaki şekildedir.\ndegiskenAdi := \u0026#34;metin ifadesi\u0026#34; Şimdi bir uygulama örneği ile devam edelim.\npackage main import \u0026#34;fmt\u0026#34; func main() { stringIfadesi := \u0026#34;GOKAYBURUC.DEV\u0026#34; // String ifadesinin uzunluğunun görüntülenmesi fmt.Printf(\u0026#34;Length of the string is:%d\u0026#34;, len(stringIfadesi)) // String ifadesinin görüntülenmesi fmt.Printf(\u0026#34;\\nString is: %s\u0026#34;, stringIfadesi) // String ifadesinin veri türünün görüntülenmesi fmt.Printf(\u0026#34;\\nType of str is: %T\u0026#34;, stringIfadesi) } Boolean (Mantıksal) Bir veri tipinin mantıksal değerler olan true ya da false döndürdüğü ifadelerdir. Bir koşullu işlemin sonucu bilgisayar tarafından geçerli olduğu noktada true geçersiz olduğu noktada ise false değerini döndürür.\n   Veri Tipi Açıklama     true koşul sınamasının olumlu olması sonucu dönen değer   false koşul sınamasının olumsuz olması sonucu dönen değer     Boolean Uygulaması package main import \u0026#34;fmt\u0026#34; func main(){ var a = 25 var b = 45 a=25 b=45 //mantıksal sorgu \tsorguBir := (a \u0026gt; b) sorguİki := (a \u0026lt; b) sorguUc := (a == b) sorguDort := (a != b) fmt.Println(sorguBir) fmt.Println(sorguİki) fmt.Println(sorguUc) fmt.Println(sorguDort) // Deger ataması \tvar ehliyet bool = true var ruhsat bool = false fmt.Printf(\u0026#34;Ehliyet : %v\\nRuhsat : %v \\n\u0026#34;, ehliyet,ruhsat) } Complex ( Karmaşık ) Matematik gösterimi i ve j ye bağlı olan ve iki boyutlu bir analitik düzlem üstünde gösterilen sayılar için sistem hafızasında tutulan veri tipidir.\nKomplek Sayi j + Xi seklinde yazılır. Yani sayının bir imajiner bir de reel kısmı mevcuttur. Sonuçlarımız da bu şekilde döndürülecektir.\nYazım şekili\nvar degiskenAdi complex64 = complex(2,15) ikinci yazım şekli\nvar degiskenAdi := complex(2,15) Komplex sayı veri tipine ait tablo aşağıda yer almaktadır.\n   Veri Tipi Açıklama     complex64 float32 değerini reel (j) ve imajiner (i) kısımda tutan deger   complex128 float64 değerini reel (j) ve imajiner(i) kısımda tutan değer    Aşağıda açıklama örneğimiz yer almaktadır.\n// Go program to illustrate // the use of complex numbers package main import \u0026#34;fmt\u0026#34; func main() { var a complex128 = complex(6, 2) var b complex64 = complex(9, 2) //  fmt.Println(a) fmt.Println(b) // Display the type  fmt.Printf(\u0026#34;The type of a is %T and \u0026#34;+ \u0026#34;the type of b is %T\u0026#34;, a, b) } Kaynakça  https://www.geeksforgeeks.org/data-types-in-go/ https://go.dev/tour/basics/11 https://www.programiz.com/golang/data-types  "},{"id":2,"href":"/docs/posts/variables/","title":"Değişkenler (Variables)","section":"Docs","content":"Değişkenler (Variables) Değişken ( Variable ) , bir değeri tutmak için bir depolama konumudur. İzin verilen değerler kümesi, değişkenin türüne göre belirlenir.\n// string degisken turu var isim string = \u0026#34;Gokay\u0026#34; Yani elimizde isim diye bir değişken olduğunu var sayalım. İzin verilen deger olarak degisken türü dikkate alındığında string type bir ifade olduğunu düşünürsek bu ifade yalnızca string veri tipinde tutulabilir. Yani yazı olarak saklanabilir.\n string olarak saklanan bir değişkene, bir tam sayı integer veya ondalıklı sayı float değer verirsek, veyahut mantıksal bool bir ifade verirsek sistemden hata alırız. isim değişkenimiz yalnızca string olarak sistemde saklanabilir.\n  Değişken ifadeleri adı üzerinde değişebilen ifadelerdir. Sabitler const ifadelerinden farkları tanımlandıktan sonra sistemdeki değerlerinin değişebilmesinden ileri gelmektedir.\nDeğişkenlerin özellikleri  İşleme tabi tutulabilirler Üzerlerine defalarca değer ataması yapılabilir. Sistemden çağrıldıkları zaman son atanan değeri döndürürler.  Değişken Tanımlama Peki nasıl değişken tanımlarız. Tanımlama şekilleri nelerdir?\nİlk tanımlama şeklimiz detaylı tanımlama şeklidir.\nvar country string = \u0026#34;Turkey\u0026#34; Bu tanımlama ifadesini biraz daha kısaltabiliriz.\n GO programlama dili otomatik olarak değişken türü tanıma ve atama özelliğine sahiptir.\n var country = \u0026#34;Turkey\u0026#34; Eğer ifademizi bir fonksiyon içinde tanımlıyorsak alternatif bir kısa yazım daha mevcuttur. Bu ifadede := karakterleri ile eşitlik yazımı mevcuttur.\n Bu tanımlama yanlızca fonksiyon scope\u0026rsquo;u içinde tanımlamalarda mümkündür.\n func main(){ country := \u0026#34;Turkey\u0026#34; } Birden Çok Değişkeni Tek Satırda Tanımlama Eğer elimizde birden çok değişken varsa ve bunları tek satır içerisinde tanımlamak istiyorsak aşağıdaki yazım türünde tanımlarız.\nvar b, c int = 1, 2 Burada b ve c olmak üzere, iki adet int ifadesini tek bir satır içerisinde virgül ile ayırarak tanımladık.\nAynı şekilde değişken tipini yazmadan da değişkene değer atama işlemi yapabiliyoruz. GO otomatik olarak değişken türünü tanımlayıp atamasını yapmaktadır.\nvar en, boy = 100, 50 Peki ifadelerden biri string diğeri bool olsaydı nasıl tanımlayacaktık?\nvar para bool, miktar float64 = true, 5500.25 aynı ifadeyi bir de kısaltılmış olarak yazabiliriz.\nvar para, miktar = true, 5500.25 Biraz daha karmaşık bir şekilde tanımlama işlemi yapalım.\nvar isim ,soyisim , matematik , edebiyat , gecmeDurum = \u0026#34;Ahmet\u0026#34;,\u0026#34;YILMAZ\u0026#34;, 75, 83, true Uygulama Örneği Aşağıda bir uygulamamız bulunuyor. Bu uygulamada birden çok değişken tanımlıyoruz ve fmt yardımı ile sonuçları ekrana yazdırıyoruz.\npackage main import \u0026#34;fmt\u0026#34; func main(){ sehir := \u0026#34;Edirne\u0026#34; var kilo float64 = 75.3 var boy float64 = 182.3 yas := 35 var mezuniyet,askerlik bool = true, true fmt.Println(boy,kilo,yas,sehir) fmt.Println(mezuniyet, askerlik) var isim ,soyisim , matematik , edebiyat , gecmeDurum = \u0026#34;Ahmet\u0026#34;,\u0026#34;YILMAZ\u0026#34;, 75, 83, true // alternatif kısa gösterim \t//isim ,soyisim , matematik , edebiyat , gecmeDurum := \u0026#34;Ahmet\u0026#34;,\u0026#34;YILMAZ\u0026#34;, 75, 83, true  fmt.Println(isim,soyisim,matematik,edebiyat,gecmeDurum) } Kaynakça  https://gobyexample.com/variables https://golangbot.com/variables/ https://zetcode.com/golang/variable/ https://www.w3schools.com/go/go_variable_multi.php  "},{"id":3,"href":"/docs/posts/constants/","title":"Sabitler (Constants)","section":"Docs","content":"Sabitler (Constants) Constant ifadeler sabitler olarak bilinirler. Değişken ifadelerinden farklı olarak, bir defa değer atandığı an itibariyle sistemde sabit kalırlar. İşleme tabi tutulsalar dahi, işlem bitişinde yine değerleri sabit olmaktadır.\nYazım Biçimi - Snytax const ifade = deger HATIRLATMA: const ifadeleri scope içinde ve dışında tanımlanabilir.  const İfadelerin Veri Türleri const ifadeler aşağıda yer alan tüm veri tiplerinde veri taşıyabilirler.\n Integer - int Float - float32, float64 vs. String - string Boolean - bool Character - tek bir karakter  const İfadelerin Kullanımı GeeksForGeeks web sitesinden alınan örnek ifade aşağıda verilmiştir.\npackage main import \u0026#34;fmt\u0026#34; const PI = 3.14 func main() { const GFG = \u0026#34;GeeksforGeeks\u0026#34; fmt.Println(\u0026#34;Hello\u0026#34;, GFG) fmt.Println(\u0026#34;Happy\u0026#34;, PI, \u0026#34;Day\u0026#34;) const Correct= true fmt.Println(\u0026#34;Go rules?\u0026#34;, Correct) } ifadede görüldüğü üzere PI isimli float bir sabit değer tanımlanmıştır. Burada dikkat etmemiz gereken nokta const ifadelerinin scope (fonksiyon tanımlanan aralık) dışında da tanımlanabildiğidir.\nYazılmamış (Untyped) ve Yazılı (Typed) Sayısal Sabitler: Yazılan sabitler (typed constants), sabitlenmiş değişkenler gibi çalışır, yalnızca aynı türle birlikte çalışabilir ve tür bilgisi yazılmamış sabitler (untyped constants), değişmezler gibi çalışır, benzer türlerle birlikte çalışabilir.\n Sabitler (constants), Go\u0026rsquo;da bir türle veya türsüz olarak bildirilebilir.\n Aşağıda, hem typed hem de untyped biçimde belirtilmiş ifadeler örneklenmiştir.\n//veri tipi belirtilmemiş const untypedInteger = 123 const untypedFloating = 123.12 //veri tipi belirtilmiş const typedInteger int = 123 const typedFloatingPoint float64 = 123.12 Yazılı ve Yazılı Olmayan Sabitlere Ait Örnek Uygulama Aşağıda belirli sabitler tanımlanmıştır ve bu sabitlerle rastgele işlemler yapılmıştır.\npackage main import \u0026#34;fmt\u0026#34; const Pi = 3.14 // untyped const Euro float32 = 18.78 // typed const yil = 2022 // untyped const kurulus int = 1923 //typed  func main() { test := Euro * yil // tanımli sabit Euro ile tanımsiz sabit yil carpiliyor test2 := Pi * Euro // tanımli sabit Euro ile tanımsız sabit Pi carpiliyor test3 := Pi * yil // tanımsız sabit pi ile tanımsız sabit yil carpiliyor  /* a test3 := kurulus * Euro yukarıdaki ifade hata verecektir cünkü kurulus tanımlı sabit Euro da tanımlı sabittir ve veri tipleri farklıdır. tip dönüşümü gerekmektedir. kurulus int degerini float32 \u0026#39;ye cevirerek isleme sokabiliriz.*/ test4 := float32(kurulus) * Euro fmt.Println(test) fmt.Println(test2) fmt.Println(test3) fmt.Println(test4) } Tip Dönüşümü İfademizde notları incelediyseniz tanımlama sırasında bir noktada tip dönüşümü yaptık. Bunun sebebi ise bu değerin tip tanımlı bir sabit olmasıdır. Bu sebepten dolayı GO otomatik olarak uygun değere çeviremez ve yeniden tip elle tip tanımlaması yapmamız gerekir.\n// tip dönüşümü test4 := float32(kurulus) * Euro //int veri tipini float32 veri tipine cevirdik Sabit Türleri GOLANG içerisinde sabit türleri çeşitli olmakla birlikte temel başlıklar altında toplanabilir.\n Metin Sabitleri - String Literals Sayısal Sabitler - (Integer, Float , Complex ) Boolean Sabitleri  Metin Sabitleri  Go, iki tür değişmez stringyi destekler, yani ” ” (çift tırnak stili) ve ' \u0026lsquo;(geri alıntı). string ifadeler + ve += operatörleriyle birleştirilebilir. Bir string, karakter değişmezlerine benzer karakterler içerir: düz karakterler (plain characters), kaçış dizileri (escape sequences ) ve evrensel karakterler (universal characters). Ve bu, yazılmamış karakterlerdendir. string türlerinin sıfır değerleri, değişmez olarak ” ” veya ” ile gösterilebilen boş stringlerdir. string türlerinin tümü, == (equal) , != (not equal) ve (aynı türlerin karşılaştırılması için) gibi operatörler kullanılarak karşılaştırılabilir.  package main import \u0026#34;fmt\u0026#34; func main() { const A = \u0026#34;GOKAYBURUC.DEV\u0026#34; var B = \u0026#34;Medium Blog Page\u0026#34; // Concat strings. - String ifadelerin birleştirilmesi \tvar karsilama = A+ \u0026#34; \u0026#34; + B karsilama += \u0026#34;!\u0026#34; fmt.Println(karsilama) // Compare strings. - String ifadelerin karşılaştırılması \tfmt.Println(A == \u0026#34;GOKAYBURUC\u0026#34;) fmt.Println(B \u0026lt; A) } Boolean Sabitleri true ve false değeri alan sabitlerdir.\npackage main import \u0026#34;fmt\u0026#34; const Pi = 3.14 func main() { // degeri true olan bir const tanımladık \tconst trueConst = true // Type definition using type keyword - Veri Tipi Tanımlama \ttype myBool bool // const ifadeyi bir değişkene atadık \tvar defaultBool = trueConst // izin verilir \tvar customBool myBool = trueConst // izin verilir \t// defaultBool = customBool // izin verilmez \tfmt.Println(defaultBool) fmt.Println(customBool) } Tamsayı (Integer) Sabitleri Tamsayı integer sabitleri çeşitli değişkenlik göstermektedir.\nBurada sayı yazılımları :\n Decimal : Ondalık ( 10 luk sayı sistemi ) Octal : Sekizlik ( 8 \u0026lsquo;lik sayı sistemi ) Hexadecimal : On altılık (16\u0026rsquo;lık sayı sistemi) Int : Tamsayı Unsigned Int : İmzasız integer Long : Uzun veri tipi - C Kökenli bir veri tipidir. ( 2^64 ifadesini getirir)  85 /* decimal */ 0213 /* octal */ 0x4b /* hexadecimal */ 30 /* int */ 30u /* unsigned int */ 30l /* long */ 30ul /* unsigned long */ 212 /* Legal */ 215u /* Legal */ 0xFeeL /* Legal */ 078 /* Illegal: 8 is not an octal digit */ 032UU /* Illegal: cannot repeat a suffix */ Örnek ifademizi tanımlayalım.\npackage main import \u0026#34;fmt\u0026#34; const ekmek int = 5 func main() { //const ekmek = 5  var sepet int = 30 yarimSepet := sepet / 2 yarimEkmek := ekmek / 2 fmt.Println(yarimEkmek) fmt.Println(yarimSepet * ekmek) // bu ifade hata verecektir. sabit bir deger ikinci bir atama kabul etmez ekmek = ekmek / 2 fmt.Println(ekmek) } Ondalık (Float) Sabitleri Ondalık sabitler olarak tanımlanır.\n3.14159 /* Legal */ 314159E-5L /* Legal */ 510E /* Illegal: incomplete exponent */ 210f /* Illegal: no decimal or exponent */ .e55 /* Illegal: missing integer or fraction */ Kompleks Sayı (Complex) Sabitleri 2 değerle tanımlanan komplex sayılar için kullanılır. Aşağıdaki iki tanımlama da geçerli bir tanımlamadır.\nconst ilk = (0.0, 0.0) const sinirlar = (-123.456E+30, 987.654E-29) Tip Tanımlama - Type Definition Type Definition (Tip Tanımlama): GOLANG içinde eğer yeni bir tip tanımlamak istiyorsanız\n//type tipAdı veriTürü type benimVeriTipim string sentaks değerini izlersiniz.\nKaynakça  https://go.dev/tour/basics/15 https://www.geeksforgeeks.org/constants-go-language/  "},{"id":4,"href":"/docs/posts/switch-case/","title":"Anahtar Durum İfadeleri (Switch Case )","section":"Docs","content":"Anahtar Durum İfadeleri (Switch Case) Switch ifadesi, çok yollu bir dal ifadesidir. İfadenin değerine dayalı olarak yürütmeyi bir kodun farklı bölümlerine aktarmak için etkili bir yol sağlar. Basit bir ifade ile demiryolu makası gibi düşünülebilir.\nGo dili, iki tür anahtar deyimini destekler:\n İfade Switch Tip Switch  İfade Switch İfade switch, C, C++, Java dilindeki switch ifadesine benzer. İfadenin değerine bağlı olarak yürütmeyi kodun farklı bölümlerine göndermenin kolay bir yolunu sağlar.\nSyntax:\nswitch optstatement; optexpression{ case expression1: Statement.. case expression2: Statement.. ... default: Statement.. } Önemli Noktalar:**\n switch ifadesi sonrasında yazılan optexpression ve optstatement opsiyonel ifadelerdir. Eğer hem optexpression hem de optstatement ifadede mevcut ise ikisinin arasına noktalı virgül ; işareti koymak gereklidir. Eğer switch herhangi bir ifade içermiyorsa, derleyici ifadenin true olduğunu varsayar. optstatement değişken tanımlamaları, artış ya da atama durumları, fonksiyon çağrıları vb. gibi basit durumları içerir. Eğer değişken optstatement içerisinde görüntülenirse, değişkenin aralığı switch ifadesi ile sınırlıdır. switch ve case ifadeleri dahili olarak break ile durdurulmaz. Fakat şart sağlandığında otomatik olarak anahtar değeri değişir ve bir sonraki aşamaya geçilir. default ifadesi switch ifadesinde isteğe bağlı olarak kullanılır. case ifadesi birden fazla değişken içerirse bu ifadeler virgül (,) ile ayrılırlar. Eğer case ifadesi herhangi bir ifade içermiyorsa, sistem bu ifadenin değerinin true kabul eder.  Example 1:\npackage main import \u0026#34;fmt\u0026#34; func main(){ switch day:=4; day { case 1: fmt.Println(\u0026#34;Pazartesi\u0026#34;) case 2: fmt.Println(\u0026#34;Salı\u0026#34;) case 3: fmt.Println(\u0026#34;Çarşamba\u0026#34;) case 4: fmt.Println(\u0026#34;Perşembe\u0026#34;) case 5: fmt.Println(\u0026#34;Cuma\u0026#34;) case 6: fmt.Println(\u0026#34;Cumartesi\u0026#34;) case 7: fmt.Println(\u0026#34;Pazar\u0026#34;) default: fmt.Println(\u0026#34;Geçerli Bir gün Girmediniz!\u0026#34;) return } } Çıktı:\nPerşembe Example 2:\npackage main import ( \u0026#34;fmt\u0026#34; ) func main(){ var secim int = 3 switch secim { case 1: fmt.Println(\u0026#34;Cemil\u0026#34;) case 2: fmt.Println(\u0026#34;Numan\u0026#34;) case 3: fmt.Println(\u0026#34;Şaban\u0026#34;) case 4: fmt.Println(\u0026#34;Haydar\u0026#34;) default: fmt.Println(\u0026#34;Afrikalı Nuri\u0026#34;) return } } Output:\nŞaban Example 3:\n`\npackage main import \u0026#34;fmt\u0026#34; func main() { var secim string = \u0026#34;Huseyin\u0026#34; switch secim{ case \u0026#34;Ahmet\u0026#34;,\u0026#34;Mehmet\u0026#34;: // \u0026#34;Ahmet\u0026#34; ya da \u0026#34;Mehmet\u0026#34; verilirse bu uyarı gelir \tfmt.Println(\u0026#34;Değil\u0026#34;) case \u0026#34;Cemil\u0026#34;, \u0026#34;Huseyin\u0026#34;,\u0026#34;Numan\u0026#34;: // eğer verilen 3 degerden biri secimde tanımlanırsa bu uyarı gelir \tfmt.Println(\u0026#34;Alakası Yok!\u0026#34;) case \u0026#34;Gokay\u0026#34;: fmt.Println(\u0026#34;Aradığınız adamı buldunuz!\u0026#34;) default: fmt.Println(\u0026#34;Bir adam ismi girin!\u0026#34;) return } } Output:\nAlakası Yok! Tip Switch (Type Switch) Tip switch anahtarı, türleri karşılaştırmak istediğinizde kullanılır. Bu anahtarda, durum, anahtar ifadesinde bulunan tür ile karşılaştırılacak olan türü içerir.\nSyntax:\nswitch optstatement; typeswitchexpression{ case typelist 1: Statement.. case typelist 2: Statement.. ... default: Statement.. } Önemli noktalar:\n Opsiyonel ifade, yani optstatement, switch ifadesindeki ile benzerdir. Bir optstatement birden fazla değer içeriyorsa ve bu değerler virgül(,) ile ayrılırlar. switch deyimi türünde, case ve default deyimi herhangi bir break deyimi içermez. Ancak, programınız gerekliyse, break ve fallthrough ifadesini kullanmanıza izin verilir. typeswitchexpression\u0026rsquo; de default isteğe bağlıdır. typeswitchexpression, sonucu bir tür olan bir ifadedir. typeswitchexpression içinde := operatörü kullanılarak bir ifade atanırsa, bu değişkenin türü, case yan tümcesinde bulunan türe bağlıdır. case yan tümcesi iki veya daha fazla tür içeriyorsa, değişkenin türü, typeswitchexpression içinde oluşturulduğu türdür.  Example:\npackage main import \u0026#34;fmt\u0026#34; func main() { var value interface{} switch q:= value.(type) { case bool: fmt.Println(\u0026#34;value is of boolean type\u0026#34;) case float64: fmt.Println(\u0026#34;value is of float64 type\u0026#34;) case int: fmt.Println(\u0026#34;value is of int type\u0026#34;) default: fmt.Printf(\u0026#34;value is of type: %T\u0026#34;, q) } } Output:\nvalue is of type: \u0026lt;nil\u0026gt;[Finished in 634ms] KAYNAKÇA:\n1.https://www.geeksforgeeks.org/type-switches-in-golang/ 2.https://www.geeksforgeeks.org/switch-statement-in-go/\npackage main import \u0026#34;fmt\u0026#34; "},{"id":5,"href":"/docs/posts/arrays/","title":"Diziler - Arrays","section":"Docs","content":"Diziler (Arrays) "},{"id":6,"href":"/docs/posts/loops/","title":"Döngüler (Loops)","section":"Docs","content":"Döngüler (Loops) GO programlama dilinde tek bir döngü mevcuttur; bu da for döngüsüdür. Bu döngü C, C++, Java, C# dillerindeki ile benzerlik göstermektedir. #java #cplusplus #csharp #c\nYazım Biçimi (Syntax) Yazım şekli de aşağıdaki gibidir.\nfor initialization; condition; post{ // statements.... }  Başlatma ifadesi (intialization) : Başlatma ifadesi isteğe bağlıdır ve for döngüsü başlamadan önce yürütülür. Başlatma ifadesi her zaman değişken bildirimleri, artış veya atama ifadeleri veya işlev çağrıları gibi basit bir ifadededir. Şart (condition) : Koşul ifadesi, döngünün her yinelemesinin başlangıcında değerlendirilen bir boole ifadesi içerir. Koşullu ifadenin değeri doğruysa, döngü yürütülür. Post : Post ifadesi, for döngüsünün gövdesinden sonra yürütülür. Post deyiminden sonra, koşul deyiminin değeri yanlış ise koşul deyimi tekrar değerlendirilir, ardından döngü sona erer. Statement (Durum) : Eğer koşul sağlanırsa gövdede gerçekleşecek işlemleri belirtir.  package main import \u0026#34;fmt\u0026#34; // Main function func main() { // for döngüsü \t// Bu döngü i = 0 değeri gerçekleştiğinde başlar \t// i\u0026lt;4 şartı gerçekleşip true anahtarı ortaya çıkana kadar devam eder \t// post ifadesi i++ \u0026#39;dir. Bu da döngü boyunca i değerini 1 arttır anlamına gelir. \tfor i := 0; i \u0026lt; 4; i++{ fmt.Printf(\u0026#34;GOKAYBURUC.DEV\\n\u0026#34;) } }  Yukarıda yazdığımız kod scriptini çalıştırdığımızda işlem gerçekleşinceye kadar 4 defa ekrana \u0026ldquo;GOKAYBURUC.DEV\u0026rdquo; yazısını yazıdıracaktır.\n Sonsuz For Döngüsü (Endless For Loop) for değerini sonsuza dek tekrar edecek şekilde kullanmak için aşağıdaki ifade şeklinde yazılması gerekir.\nfor { // statement  } Bu ifadede herhangi bir şart sağlanmayacağı için döngüyü çalıştıran anahtar sonsuza dek true olarak kalacaktır. Bir önceki örneğimizde i\u0026lt;4 şartı sağlandığında değer false döneceği için döngü durmuştu.\npackage main import \u0026#34;fmt\u0026#34; func main(){ for{ fmt.Println(\u0026#34;Sonsuza dek yaz!\u0026#34;) } } İken Formatında For Döngüsü ( For Loop as While Loop) for döngüsü sırasında belirtilen şart sağlandığında döngü kesilecek şekilde yazılır. Aşağıda örnekte i değeri 3 değerini geçtiğinde döngü sonlanacaktır.\npackage main import \u0026#34;fmt\u0026#34; func main() { i:= 0 // i degeri 0 olarak tanımlanır \tfor i \u0026lt; 3 { // i degeri ilk olarak 2 sonra 4 degeri alır \t// şart sağlandığı için döngü kesilir \ti += 2 } fmt.Println(i) } For Döngüsünde Basit Aralık (Simple range in for loop) for i, j:= range rvariable{ // statement.. }  i ve j, yinelemenin değerlerinin atandığı değişkenlerdir. Yineleme değişkenleri olarak da bilinirler. İkinci değişken, yani j isteğe bağlıdır. Aralık ifadesi, döngü başlamadan önce bir kez değerlendirilir.  package main import \u0026#34;fmt\u0026#34; func main() { // array \tsehirler := []string{\u0026#34;Bursa\u0026#34;, \u0026#34;Edirne\u0026#34;, \u0026#34;İstanbul\u0026#34;} for i, j := range sehirler { fmt.Printf(\u0026#34;Sehir : %v , index : %v \\n\u0026#34;, j, i) } } string ifadeler için de for range ifadeleri kullanılabilir.\npackage main import \u0026#34;fmt\u0026#34; func main() { // \tfor i, j:= range \u0026#34;EDİRNE\u0026#34; { fmt.Printf(\u0026#34;Karakter: %U , index : %d \\n\u0026#34;, j, i) }\t} Çıktı:\nKarakter: U+0045 , index : 0 Karakter: U+0044 , index : 1 Karakter: U+0130 , index : 2 Karakter: U+0052 , index : 4 Karakter: U+004E , index : 5 Karakter: U+0045 , index : 6 Aynı ifade içerisinde\nMaps (Haritalar) için For Döngüsü Map ifadeleri bir ader anahtar ve bu anahtara bağlı bir adet değerden oluşur. Bu ifadeler için bir for-range döngüsü yapıldığında yazım aşağıdaki şekilde olacaktır.\nFOR-RANGE MAP SYNTAX :\nfor key, value := range map { // Statement.. } Aşağıda bir map ifadesi içinde plaka şehir eşleştirmesi yapılmıştır. Bu değerleri sıralamaya başlıyoruz.\npackage main import \u0026#34;fmt\u0026#34; func main() { //map tanımlanıyor plaka := map[int]string{22: \u0026#34;Edirne\u0026#34;, 39: \u0026#34;Kırklareli\u0026#34;, 59: \u0026#34;Tekirdağ\u0026#34;, 17: \u0026#34;Çanakkale\u0026#34;} // for i, j := range plaka { fmt.Printf(\u0026#34;Plaka:%v İl:%v \\n\u0026#34;, i, j) } } Bu ifadenin çıktısı şu şekilde olacaktır.\nPlaka:22 İl:Edirne Plaka:39 İl:Kırklareli Plaka:59 İl:Tekirdağ Plaka:17 İl:Çanakkale Kanal (Channel) için For-Range Döngüsü Kanal ifadelerinde de for döngüsü kullanılabilir. Burada kanal belirli şart sağlanıp kapanana kadar döngü yinelenecektir.\nfor item := range Chnl { // statements.. } Şimdi bir kanal örneği üzerinden konuya bakalım.\npackage main import \u0026#34;fmt\u0026#34; // Main function func main() { // using channel  chnl := make(chan int) //goroutines ve channel ifadeleri ile birlikte bir isimsiz fonksiyon  go func(){ chnl \u0026lt;- 100 chnl \u0026lt;- 1000 chnl \u0026lt;- 10000 chnl \u0026lt;- 100000 close(chnl) }() //ifadeyi itere edilebilir bir hale getirdik  for i:= range chnl { fmt.Println(i) } } KAYNAKÇA :\n https://www.geeksforgeeks.org/loops-in-go-language/?ref=gcse  "},{"id":7,"href":"/docs/posts/functions/","title":"Fonksiyonlar (Functions)","section":"Docs","content":"Fonksiyonlar (Functions) Bir fonksiyon (işlev), sıfır veya daha fazla giriş parametresinin sıfır veya daha fazla çıkış parametresine eşlenmesidir.\nHATIRLATMA: Giriş parametreleri fonksiyonlarda argüman olarak adlandırılırlar. Konu içerisinde geçen argüman ifadeleri fonksiyonlara giriş yapılan değerler anlamına gelir.  Fonksiyon Kullanmanın Avantajları Fonksiyonların (İşlevlerin) kullanmanın avantajları şunlardır:\n Kod tekrarını azaltma Karmaşık problemleri daha basit parçalara ayırma Kodun netliğini artırma Kodun yeniden kullanımı Bilgi gizleme  Fonksiyonların Uygulama Alanları Fonksiyonlar GO programlama dilini daha esnek hale getirirler.\n Fonksiyonlar değişkenlere atanabilirler Fonksiyonlara argüman olarak iletilebilir Fonksiyonlardan döndürülebilir  Fonksiyonların Yapısı Fonksiyonlar, belirli kısımlardan oluşur.\nfunc FonksiyonAdi(parametreler) döndürülecekVeri Tipi { //gövde - body } Yukarıda bir fonksiyonun temel yapısını görüyorsunuz.\n GO dilinde bir fonksiyon yazarken önce func ifadesi yazılır. func ifadesi sonrasında fonksiyonun adı yazılır. Bu yazım sırasında sayı ve boşluk ifadeleri kullanılmaz. Eğer kullanılacaksa fonksiyona giriş yapılacak argüman (argument) ifadeleri () içine yazılır. Döndürülecek veri tipi return ifadesi sonrasında fonksiyondan çıkış yapacak değeri ifade eder. Bu değerin veri tipi () sonrasında yazılır. {} süslü parantez ile fonksiyon gövdesi body ifadesi oluşturulur. Fonksiyonun yapacağı işlemler bu parantez içinde kalan bölgeye yazılır.  func Go\u0026rsquo;daki işlevler func anahtar sözcüğüyle oluşturulur.\n// Fonksiyon Gövdesi - function body func SayHi(name string) string { // islemler - transactions } return İşlevlerden değer döndürmek için return anahtar sözcüğünü kullanırız. Return ifadesinde döndürülecek verinin türü () ifadesi sonrasında belirtilir. string , int, float gibi ifadelerle belirtilir.\nfunc Merhaba(isim string) string { fmt.Println(\u0026#34;Merhaba \u0026#34;, isim) // cumle isimli degisken \tcumle := \u0026#34;Merhaba \u0026#34; + isim + \u0026#34; hoşgeldin!\u0026#34; // degiskenin döndürülmesi  return cumle } Fonksiyon Gövdesi - Function Body Fonksiyonun gövdesi, fonksiyon çağrıldığında yürütülen ifadelerden oluşur. Gövde, bir çift kıvrık parantez {} ile sınırlandırılmıştır.\nfunc Merhaba(isim string) string { // } Fonksiyonların Çağırılması - Function Calling Bir fonksiyonu çağırmak için adını yazar ve ardından yuvarlak parantezler () koyarız.  Bir fonksiyon parametre alabilir veya almayabilir.\nmain Fonksiyonu main isimli fonksiyon go programlama dilinin modül - paket mimarisinin temel taşıdır ve başlatıcı fonksiyon olma özelliği taşır. Her go projesinde varsayılan olarak yer alan bir fonksiyondur.\nGO programlama dilinde biz yazmasak dahil her başlatılan projede bir main paketi ve main fonksiyonu mevcuttur.  package main func main(){ // tüm islemler main isimli pakette ve main isimli  //fonksiyonun baslattigi olaylar zinciri ile gerçekleşir. } GO programlama dilinde bir paket içinde gerçekleşen tüm işlemler main isimli paket altında ve main fonksiyonun başlattığı ve yürüttüğü işlemler ile gerçekleşir.  Fonksiyon Örneği package main import \u0026#34;fmt\u0026#34; func main() { // fonksiyon cagirma - function call \tx := SayHi(\u0026#34;Gokay\u0026#34;) fmt.Println(\u0026#34;Return : \u0026#34;, x) } // Fonksiyon func SayHi(name string) string { fmt.Println(\u0026#34;Hello \u0026#34;, name) sentence := \u0026#34;Hello \u0026#34; + name + \u0026#34; welcome!\u0026#34; return sentence } Basit Fonksiyon Yazımı Örneği Aşağıda toplama işlemi yapan bir fonksiyon yazdık. Bu fonksiyon xotomatik olarak toplama işlemi gerçekleştirir.\npackage main import \u0026#34;fmt\u0026#34; func main() { x := 4 y := 5 z := topla(x, y) fmt.Printf(\u0026#34;Çıktı: %d\\n\u0026#34;, z) } func topla(a int, b int) int { return a + b } topla isimli fonksiyon tanımlanırken a ve b isimli argümanlar int veri tipinde verilmiştir. Bu sisteme girilecek verilerin int formatında olması gerektiğini belirtir.\n() dışında kalan int ifadesi ise, işlem sonrasında return ifadesinin yanında döndürülecek verinin tipinin int olacağını belirtmektedir.\nYazdığımız fonksiyon a ve b isimli değişkenkenleri toplayarak onucu ekrana yazdırır.\n"},{"id":8,"href":"/docs/posts/operators/","title":"Operatörler - Operators","section":"Docs","content":"Operatörler - Operatörs "},{"id":9,"href":"/docs/posts/conditionals/","title":"Şartlı İfadeler (If - Else Conditionals)","section":"Docs","content":"Şartlı İfadeler (If - Else Conditionals) "},{"id":10,"href":"/docs/posts/slices/","title":"Dilimler - Slices ","section":"Docs","content":"Dilimler (Slices) "}]